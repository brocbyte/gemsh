#include "shell.h"

int initTokensTable(char *line);
int tokensIsEmpty();
token *tokensGetNextElement();
token *tokensCheckNextElement();
void tokensSkipElement();

static job *parseJob();
static process *parseProcess(char **infile, char **outfile, char **appfile);



int isControlSymbol(char c)
{
    return (c == '|' || c == ';' || c == '&' || c == '>' || c == '<');
}

/**
 * ожидаемый ввод: job1 [&;] job2 [&;] ...
 * хэндлит '&', ';', т.к. это основной элемент для разделения заданий
 * договоренность: каждая функция должна "прочитывать" только те токены, которые она хэндлит
*/
int parseline(char *line)
{
    int tokens = initTokensTable(line);
    if (tokens == -1)
        return 0;

    job *currentJob = first_job = 0;
    /* условие окончания строки - отсутствие токенов */
    while (!tokensIsEmpty())
    {
        token *t = tokensCheckNextElement();
        switch (t->type)
        {
        case AMPERSAND:
            if (currentJob)
            {
                currentJob->foreground = 0;
                tokensSkipElement();
            }
            else
            {
                /* пытаемся сделать фоновым задание, которое по факту не существует */
                fprintf(stderr, "syntax error\n");
                return 0;
            }
            break;
        case SEMICOLON:
            tokensSkipElement();
            break;
        default:
            if (currentJob)
            {
                currentJob->next = parseJob();
                currentJob = currentJob->next;
            }
            else
            {
                /* это первое задание в строке */
                first_job = currentJob = parseJob();
            }
            break;
        }
    }

    return tokens;
}

/**
 * ожидаемый вход: "proc1 | proc2 | ... | procn"
 * хэндлит '|', т.к. это основной строительный эл-т для заданий
 * обрабатывает <> для первого и последнего процесса в трубе??
*/
static job *parseJob()
{
    char *infile = 0, *outfile = 0, *appfile = 0;
    job *j = (job *)malloc(sizeof(job));
    j->next = 0;
    j->appfile = j->infile = j->outfile = 0;
    j->foreground = 1;
    j->pgid = 0;
    
    process *currentProcess = j->first_process = 0;

    token *t = tokensCheckNextElement();
    /* условия окончания задания - токены ;& или отсутствие токенов */
    while (!tokensIsEmpty() && t->type != AMPERSAND && t->type != SEMICOLON)
    {
        switch (t->type)
        {
        case PIPE:
            if (currentProcess)
            {
                /* переходим по трубе, процесс слева уже был */
                tokensSkipElement();
                /* справа от пайпа обязательно должен быть другой процесс */
                if (!(!tokensIsEmpty() && t->type != AMPERSAND && t->type != SEMICOLON))
                {
                    fprintf(stderr, "syntax error\n");
                    return j;
                }
                currentProcess->next = parseProcess(0, &outfile, &appfile);
                currentProcess = currentProcess->next;
            }
            else
            {
                fprintf(stderr, "syntax error\n");
                return j;
            }
            break;
        default:
            /* это первый процесс */
            currentProcess = j->first_process = parseProcess(&infile, &outfile, &appfile);
            break;
        }
        t = tokensCheckNextElement();
    }
    if (infile)
        j->infile = infile;
    if (outfile)
        j->outfile = outfile;
    if (appfile)
        j->appfile = appfile;
    return j;
}

/**
 * ожидаемый вход: "arg0 arg1 ... argn [<,>,>>]"
 * если infile != 0, туда нужно положить <
 * аналогично для outfile, appfile.
 * если аргумент 0, но встречается перенаправление его типа - syntax error
*/
static process *parseProcess(char **infile, char **outfile, char **appfile)
{
    process *p = (process *)malloc(sizeof(process));
    p->nargs = 0;
    p->next = 0;
    p->argv[0] = (char *)NULL;

    token *t = tokensCheckNextElement();
    while (!tokensIsEmpty() && t->type != SEMICOLON && t->type != AMPERSAND && t->type != PIPE)
    {
        switch (t->type)
        {
        case REALLYRIGHTARROW:
            /* appfile */
            tokensSkipElement();
            t = tokensGetNextElement();
            if (!t || t->type != WORD)
            {
                fprintf(stderr, "after >> should be filename\n");
                return 0;
            }
            *appfile = t->place;
            break;
        case RIGHTARROW:
            /* outfile */
            tokensSkipElement();
            t = tokensGetNextElement();
            if (!t || t->type != WORD)
            {
                fprintf(stderr, "after > should be filename\n");
                return 0;
            }
            *outfile = t->place;
            break;
        case LEFTARROW:
            /* infile */
            tokensSkipElement();
            t = tokensGetNextElement();
            if (!t || t->type != WORD)
            {
                fprintf(stderr, "after < should be filename\n");
                return 0;
            }
            *infile = t->place;
            break;
        default:
            p->argv[p->nargs++] = t->place;
            p->argv[p->nargs] = (char *)NULL;
            tokensSkipElement();
            break;
        }
        t = tokensCheckNextElement();
    }
    return p;
}
